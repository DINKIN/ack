<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Fri Feb 11 22:17:11 2005 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>LLgen, an extended LL(1) parser generator</title>
</head>
<body>


<h1 align=center>LLgen, an extended LL(1) parser generator</h1>
<a href="#1. Introduction">1. Introduction</a><br>
<a href="#2. The Extended Context-Free Syntax">2. The Extended Context-Free Syntax</a><br>
<a href="#3. Grammar Specifications">3. Grammar Specifications</a><br>
<a href="#4. Actions">4. Actions</a><br>
<a href="#5. Error Recovery">5. Error Recovery</a><br>
<a href="#6. Ambiguities and conflicts">6. Ambiguities and conflicts</a><br>
<a href="#7. The LLgen working environment">7. The LLgen working environment</a><br>
<a href="#8. Programs with more than one parser">8. Programs with more than one parser</a><br>
<a href="#References">References</a><br>
<a href="#References">References</a><br>
<a href="#Appendix A : LLgen Input Syntax">Appendix A : LLgen Input Syntax</a><br>
<a href="#Appendix B : An example">Appendix B : An example</a><br>
<a href="#Appendix C. How to use LLgen .">Appendix C. How to use LLgen .</a><br>

<hr>

<p align=center><i>ABSTRACT</i></p>

<p align=center><i>Ceriel J. H. Jacobs</i><br>
Dept. of Mathematics and Computer Science<br>
Vrije Universiteit<br>
Amsterdam, The Netherlands</p>

<p><i>LLgen</i> provides a tool for generating an efficient
recursive descent parser with no backtrack from an Extended
Context Free syntax. The <i>LLgen</i> user specifies the
syntax, together with code describing actions associated
with the parsing process. <i>LLgen</i> turns this
specification into a number of subroutines that handle the
parsing process.</p>

<p>The grammar may be ambiguous. <i>LLgen</i> contains both
static and dynamic facilities to resolve these
ambiguities.</p>

<p>The specification can be split into several files, for
each of which <i>LLgen</i> generates an output file
containing the corresponding part of the parser.
Furthermore, only output files that differ from their
previous version are updated. Other output files are not
affected in any way. This allows the user to recompile only
those output files that have changed.</p>

<p>The subroutine produced by <i>LLgen</i> calls a user
supplied routine that must return the next token. This way,
the input to the parser can be split into single characters
or higher level tokens.</p>

<p>An error recovery mechanism is generated almost
completely automatically. It is based on so called
<b>default choices</b>, which are implicitly or explicitly
specified by the user.</p>

<p><i>LLgen</i> has succesfully been used to create
recognizers for Pascal, C, and Modula-2.</p>
<a name="1. Introduction"></a>
<h2>1. Introduction</h2>

<p><i>LLgen</i> provides a tool for generating an efficient
recursive descent parser with no backtrack from an Extended
Context Free syntax. A parser generated by <i>LLgen</i> will
be called <i>LLparse</i> for the rest of this document. It
is assumed that the reader has some knowledge of LL(1)
grammars and recursive descent parsers. For a survey on the
subject, see reference (2).</p>

<p>Extended LL(1) parsers are an extension of LL(1)
parsers. They are derived from an Extended Context-Free
(ECF) syntax instead of a Context-Free (CF) syntax. ECF
syntax is described in section 2. Section 3 provides an
outline of a specification as accepted by <i>LLgen</i> and
also discusses the lexical conventions of grammar
specification files. Section 4 provides a description of the
way the <i>LLgen</i> user can associate actions with the
syntax. These actions must be written in the programming
language C, <small><small>4</small></small> which also is
the target language of <i>LLgen</i>. The error recovery
technique is discussed in section 5. This section also
discusses what the user can do about it. Section 6 discusses
the facilities <i>LLgen</i> offers to resolve ambiguities
and conflicts. <i>LLgen</i> offers facilities to resolve
them both at parser generation time and during the execution
of <i>LLparse</i>. Section 7 discusses the <i>LLgen</i>
working environment. It also discusses the lexical analyzer
that must be supplied by the user. This lexical analyzer
must read the input stream and break it up into basic input
items, called <b>tokens</b> for the rest of this document.
Appendix A gives a summary of the <i>LLgen</i> input syntax.
Appendix B gives an example. It is very instructive to
compare this example with the one given in reference (3). It
demonstrates the struggle <i>LLparse</i> and other LL(1)
parsers have with expressions. Appendix C gives an example
of the <i>LLgen</i> features allowing the user to recompile
only those output files that have changed, using the
<i>make</i> program. <small><small>1</small></small></p>
<a name="2. The Extended Context-Free Syntax"></a>
<h2>2. The Extended Context-Free Syntax</h2>

<p>The extensions of an ECF syntax with respect to an
ordinary CF syntax are:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1.</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>An ECF syntax contains the repetition operator:
&quot;N&quot; (N represents a positive integer).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>2.</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>An ECF syntax contains the closure set operator without
and with upperbound: &quot;*&quot; and &quot;*N&quot;.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>3.</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>An ECF syntax contains the positive closure set operator
without and with upperbound: &quot;+&quot; and
&quot;+N&quot;.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>4.</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>An ECF syntax contains the optional operator:
&quot;?&quot;, which is a shorthand for &quot;*1&quot;.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>5.</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>An ECF syntax contains parentheses &quot;[&quot; and
&quot;]&quot; which can be used for grouping.</p>
</td>
</table>

<p>We can describe the syntax of an ECF syntax with an ECF
syntax :</p>
<pre>     grammar         : rule +
                     ;
</pre>

<p>This grammar rule states that a grammar consists of one
or more rules.</p>
<pre>     rule            : nonterminal &rsquo;:&rsquo; productionrule &rsquo;;&rsquo;
                     ;
</pre>

<p>A rule consists of a left hand side, the nonterminal,
followed by &quot;:&quot;, the <b>produce symbol</b>,
followed by a production rule, followed by a &quot;;&quot;,
indicating the end of the rule.</p>
<pre>     productionrule  : production [ &rsquo;|&rsquo; production ]*
                     ;
</pre>

<p>A production rule consists of one or more alternative
productions separated by &quot;|&quot;. This symbol is
called the <b>alternation symbol</b>.</p>
<pre>     production      : term *
                     ;
</pre>

<p>A production consists of a possibly empty list of terms.
So, empty productions are allowed.</p>
<pre>     term            : element repeats
                     ;
</pre>

<p>A term is an element, possibly with a repeat
specification.</p>
<pre>     element         : LITERAL
                     | IDENTIFIER
                     | &rsquo;[&rsquo; productionrule &rsquo;]&rsquo;
                     ;
</pre>

<p>An element can be a LITERAL, which basically is a single
character between apostrophes, it can be an IDENTIFIER,
which is either a nonterminal or a token, and it can be a
production rule between square parentheses.</p>
<pre>     repeats         : &rsquo;?&rsquo;
                     | [ &rsquo;*&rsquo; | &rsquo;+&rsquo; ] NUMBER ?
                     | NUMBER ?
                     ;
</pre>

<p>These are the repeat specifications discussed above.
Notice that this specification may be empty.</p>

<p>The class of ECF languages is identical with the class
of CF languages. However, in many cases recursive
definitions of language features can now be replaced by
iterative ones. This tends to reduce the number of
nonterminals and gives rise to very efficient recursive
descent parsers.</p>
<a name="3. Grammar Specifications"></a>
<h2>3. Grammar Specifications</h2>

<p>The major part of a <i>LLgen</i> grammar specification
consists of an ECF syntax specification. Names in this
syntax specification refer to either tokens or nonterminal
symbols. <i>LLgen</i> requires token names to be declared as
such. This way it can be avoided that a typing error in a
nonterminal name causes it to be accepted as a token name.
The token declarations will be discussed later. A name will
be regarded as a nonterminal symbol, unless it is declared
as a token name. If there is no production rule for a
nonterminal symbol, <i>LLgen</i> will complain.</p>

<p>A grammar specification may also include some C
routines, for instance the lexical analyzer and an error
reporting routine. Thus, a grammar specification file can
contain declarations, grammar rules and C-code.</p>

<p>Blanks, tabs and newlines are ignored, but may not
appear in names or keywords. Comments may appear wherever a
name is legal (which is almost everywhere). They are
enclosed in /* ... */, as in C. Comments do not nest.</p>

<p>Names may be of arbitrary length, and can be made up of
letters, underscore &quot;_&quot; and non-initial digits.
Upper and lower case letters are distinct. Only the first 50
characters are significant. Notice however, that the names
for the tokens will be used by the C-preprocessor. The
number of significant characters therefore depends on the
underlying C-implementation. A safe rule is to make the
identifiers distinct in the first six characters, case
ignored.</p>

<p>There are two kinds of tokens: those that are declared
and are denoted by a name, and literals.</p>

<p>A literal consists of a character enclosed in
apostrophes &quot;&rsquo;&quot;. The &quot;\&quot; is an
escape character within literals. The following escapes are
recognized :</p>

<p align=center><img src="grohtml-100191.png"></p>

<p>Names representing tokens must be declared before they
are used. This can be done using the
&quot;<b>%token</b>&quot; keyword, by writing</p>
<pre>%token  name1, name2, . . . ;
</pre>

<p><i>LLparse</i> is designed to recognize special
nonterminal symbols called <b>start symbols</b>.
<i>LLgen</i> allows for more than one start symbol. Thus,
grammars with more than one entry point are accepted. The
start symbols must be declared explicitly using the
&quot;<b>%start</b>&quot; keyword. It can be used whenever a
declaration is legal, f.i.:</p>
<pre>%start LLparse, specification ;
</pre>

<p>declares &quot;specification&quot; as a start symbol and
associates the identifier &quot;LLparse&quot; with it.
&quot;LLparse&quot; will now be the name of the C-function
that must be called to recognize
&quot;specification&quot;.</p>
<a name="4. Actions"></a>
<h2>4. Actions</h2>

<p><i>LLgen</i> allows arbitrary insertions of actions
within the right hand side of a production rule in the ECF
syntax. An action consists of a number of C statements,
enclosed in the brackets &quot;{&quot; and
&quot;}&quot;.</p>

<p><i>LLgen</i> generates a parsing routine for each rule
in the grammar. The actions supplied by the user are just
inserted in the proper place. There may also be declarations
before the statements in the action, as the &quot;{&quot;
and &quot;}&quot; are copied into the target code along with
the action. The scope of these declarations terminates with
the closing bracket &quot;}&quot; of the action.</p>

<p>In addition to actions, it is also possible to declare
local variables in the parsing routine, which can then be
used in the actions. Such a declaration consists of a number
of C variable declarations, enclosed in the brackets
&quot;{&quot; and &quot;}&quot;. It must be placed right in
front of the &quot;:&quot; in the grammar rule. The scope of
these local variables consists of the complete grammar
rule.</p>

<p>In order to facilitate communication between the actions
and <i>LLparse</i>, the parsing routines can be given C-like
parameters. Each parameter must be declared separately, and
each of these declarations must end with a semicolon. For
the last parameter, the semicolon is optional.</p>

<p>So, for example</p>
<pre>expr(int *pval;) { int fact; } :
                /*
                 * Rule with one parameter, a pointer to an int.
                 * Parameter specifications are ordinary C declarations.
                 * One local variable, of type int.
                 */
        factor (&amp;fact)          { *pval = fact; }
                /*
                 * factor is another nonterminal symbol.
                 * One actual parameter is supplied.
                 * Notice that the parameter passing mechanism is that
                 * of C.
                 */
        [ &rsquo;+&rsquo; factor (&amp;fact)    { *pval += fact; } ]*
                /*
                 * remember the &rsquo;*&rsquo; means zero or more times
                 */
        ;

</pre>

<p>is a rule to recognize a number of factors, separated by
&quot;+&quot;, and to compute their sum.</p>

<p><i>LLgen</i> generates C code, so the parameter passing
mechanism is that of C, as is shown in the example
above.</p>

<p>Actions often manipulate attributes of the token just
read. For instance, when an identifier is read, its name
must be looked up in a symbol table. Therefore, <i>LLgen</i>
generates code such that at a number of places in the
grammar rule it is defined which token has last been read.
After a token, the last token read is this token. After a
&quot;[&quot; or a &quot;|&quot;, the last token read is the
next token to be accepted by <i>LLparse</i>. At all other
places, it is undefined which token has last been read. The
last token read is available in the global integer variable
<i>LLsymb</i>.</p>

<p>The user may also specify C-code wherever a
<i>LLgen</i>-declaration is legal. Again, this code must be
enclosed in the brackets &quot;{&quot; and &quot;}&quot;.
This way, the user can define global declarations and
C-functions. To avoid name-conflicts with identifiers
generated by <i>LLgen</i>, <i>LLparse</i> only uses names
beginning with &quot;LL&quot;; the user should avoid such
names.</p>
<a name="5. Error Recovery"></a>
<h2>5. Error Recovery</h2>

<p>The error recovery technique used by <i>LLgen</i> is a
modification of the one presented in reference (7). It is
based on <b>default choices</b>, which just are what the
word says, default choices at every point in the grammar
where there is a choice. Thus, in an alternation, one of the
productions is marked as a default choice, and in a term
with a non-fixed repetition specification there will also be
a default choice (between doing the term (once more) and
continuing with the rest of the production in which the term
appears).</p>

<p>When <i>LLparse</i> detects an error after having parsed
the string <i>s</i>, the default choices enable it to
compute one syntactically correct continuation, consisting
of the tokens <i>t</i> <small><small>1</small></small>
...<i>t <small><small>n</small></small></i> , such that
<i>st</i> <small><small>1</small></small> ...<i>t
<small><small>n</small></small></i> is a string of tokens
that is a member of the language defined by the grammar.
Notice, that the computation of this continuation must
terminate, which implies that the default choices may not
invoke recursive rules.</p>

<p>At each point in this continuation, a certain number of
other tokens could also be syntactically correct, f.i. the
token <i>t</i> is syntactically correct at point <i>t
<small><small>i</small></small></i> in this continuation, if
the string <i>st</i> <small><small>1</small></small> ...<i>t
<small><small>i</small></small> ts</i>
<small><small>1</small></small> is a string of the language
defined by the grammar for some string <i>s</i>
<small><small>1</small></small> and i &gt;= 0.</p>

<p>The set <i>T</i> containing all these tokens (including
<i>t</i> <small><small>1</small></small> ,...,<i>t
<small><small>n</small></small></i> ) is computed. Next,
<i>LLparse</i> discards zero or more tokens from its input,
until a token <i>t</i> &isin; <i>T</i> is found. The error
is then corrected by inserting i (i &gt;= 0) tokens <i>t</i>
<small><small>1</small></small> ...<i>t
<small><small>i</small></small></i> , such that the string
<i>st</i> <small><small>1</small></small> ...<i>t
<small><small>i</small></small> ts</i>
<small><small>1</small></small> is a string of the language
defined by the grammar, for some <i>s</i>
<small><small>1</small></small> . Then, normal parsing is
resumed.</p>

<p>The above is difficult to implement in a recursive
decent parser, and is not the way <i>LLparse</i> does it,
but the effect is the same. In fact, <i>LLparse</i>
maintains a list of tokens that may not be discarded, which
is adjusted as <i>LLparse</i> proceeds. This list is just a
representation of the set <i>T</i> mentioned above. When an
error occurs, <i>LLparse</i> discards tokens until a token
<i>t</i> that is a member of this list is found. Then, it
continues parsing, following the default choices, inserting
tokens along the way, until this token <i>t</i> is legal.
The selection of the default choices must guarantee that
this will always happen.</p>

<p>The default choices are explicitly or implicitly
specified by the user. By default, the default choice in an
alternation is the alternative with the shortest possible
terminal production. The user can select one of the other
productions in the alternation as the default choice by
putting the keyword &quot;<b>%default</b>&quot; in front of
it.</p>

<p>By default, for terms with a repetition count containing
&quot;*&quot; or &quot;?&quot; the default choice is to
continue with the rest of the rule in which the term
appears, and</p>
<pre>                term+
</pre>

<p>is treated as</p>
<pre>                term term* .
</pre>

<p>It is also clear, that it can never be the default
choice to do the term (once more), because this could cause
the parser to loop, inserting tokens forever. However, when
the user does not want the parser to skip tokens that would
not have been skipped if the term would have been the
default choice, the skipping of such a term can be prevented
by using the keyword &quot;<b>%persistent</b>&quot;. For
instance, the rule</p>
<pre>commandlist : command* ;
</pre>

<p>could be changed to</p>
<pre>commandlist : [ %persistent command ]* ;
</pre>

<p>The effects of this in case of a syntax error are
twofold: The set <i>T</i> mentioned above will be extended
as if &quot;command&quot; were in the default production, so
that fewer tokens will be skipped. Also, if the first token
that is not skipped is a member of the subset of <i>T</i>
arising from the grammar rule for &quot;command&quot;,
<i>LLparse</i> will enter that rule. So, in fact the default
choice is determined dynamically (by <i>LLparse</i>). Again,
<i>LLgen</i> checks (statically) that <i>LLparse</i> will
always terminate, and if not, <i>LLgen</i> will
complain.</p>

<p>An important property of this error recovery method is
that, once a rule is started, it will be finished. This
means that all actions in the rule will be executed
normally, so that the user can be sure that there will be no
inconsistencies in his data structures because of syntax
errors. Also, as the method is in fact error correcting, the
actions in a rule only have to deal with syntactically
correct input.</p>
<a name="6. Ambiguities and conflicts"></a>
<h2>6. Ambiguities and conflicts</h2>

<p>As <i>LLgen</i> generates a recursive descent parser
with no backtrack, it must at all times be able to determine
what to do, based on the current input symbol.
Unfortunately, this cannot be done for all grammars. Two
kinds of conflicts can arise :</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1)</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>the grammar rule is of the form &quot;production1 |
production2&quot;, and <i>LLparse</i> cannot decide which
production to chose. This we call an <b>alternation
conflict</b>.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>2)</p>
</td>
<td width="16%"></td>
<td width="80%">

<p>the grammar rule is of the form &quot;[ productionrule
]...&quot;, where ... specifies a non-fixed repetition
count, and <i>LLparse</i> cannot decide whether to choose
&quot;productionrule&quot; once more, or to continue. This
we call a <b>repetition conflict</b>.</p>
</td>
</table>

<p>There can be several causes for conflicts: the grammar
may be ambiguous, or the grammar may require a more complex
parser than <i>LLgen</i> can construct. The conflicts can be
examined by inspecting the verbose (-<b>v</b>) option output
file. The conflicts can be resolved by rewriting the grammar
or by using <b>conflict resolvers</b>. The mechanism
described here is based on the attributed parsing of
reference (6).</p>

<p>An alternation conflict can be resolved by putting an
<b>if condition</b> in front of the first conflicting
production. It consists of a &quot;<b>%if</b>&quot; followed
by a C-expression between parentheses. <i>LLparse</i> will
then evaluate this expression whenever a token is met at
this point on which there is a conflict, so the conflict
will be resolved dynamically. If the expression evaluates to
non-zero, the first conflicting production is chosen,
otherwise one of the remaining ones is chosen.</p>

<p>An alternation conflict can also be resolved using the
keywords &quot;<b>%prefer</b>&quot; or
&quot;<b>%avoid</b>&quot;. &quot;<b>%prefer</b>&quot; is
equivalent in behaviour to &quot;<b>%if</b> (1)&quot;.
&quot;<b>%avoid</b>&quot; is equivalent to &quot;<b>%if</b>
(0)&quot;. In these cases however,
&quot;<b>%prefer</b>&quot; and &quot;<b>%avoid</b>&quot;
should be used, as they resolve the conflict statically and
thus give rise to better C-code.</p>

<p>A repetition conflict can be resolved by putting a
<b>while condition</b> right after the opening parentheses.
This while condition consists of a &quot;<b>%while</b>&quot;
followed by a C-expression between parentheses. Again,
<i>LLparse</i> will then evaluate this expression whenever a
token is met at this point on which there is a conflict. If
the expression evaluates to non-zero, the repeating part is
chosen, otherwise the parser continues with the rest of the
rule. Appendix B will give an example of these features.</p>

<p>A useful aid in writing conflict resolvers is the
&quot;<b>%first</b>&quot; keyword. It is used to declare a
C-macro that forms an expression returning 1 if the
parameter supplied can start a specified nonterminal,
f.i.:</p>
<pre>%first fmac, nonterm ;

</pre>

<p>declares &quot;fmac&quot; as a macro with one parameter,
whose value is a token number. If the parameter X can start
the nonterminal &quot;nonterm&quot;, &quot;fmac(X)&quot; is
true, otherwise it is false.</p>
<a name="7. The LLgen working environment"></a>
<h2>7. The LLgen working environment</h2>

<p><i>LLgen</i> generates a number of files: one for each
input file, and two other files: <i>Lpars.c</i> and
<i>Lpars.h</i>. <i>Lpars.h</i> contains
&quot;#-define&quot;s for the tokennames. <i>Lpars.c</i>
contains the error recovery routines and tables. Only those
output files that differ from their previous version are
updated. See appendix C for a possible application of this
feature.</p>

<p>The names of the output files are constructed as
follows: in the input file name, the suffix after the last
point is replaced by a &quot;c&quot;. If no point is present
in the input file name, &quot;.c&quot; is appended to it.
<i>LLgen</i> checks that the filename constructed this way
in fact represents a previous version, or does not exist
already.</p>

<p>The user must provide some environment to obtain a
complete program. Routines called <i>main</i> and
<i>LLmessage</i> must be defined. Also, a lexical analyzer
must be provided.</p>

<p>The routine <i>main</i> must be defined, as it must be
in every C-program. It should eventually call one of the
startsymbol routines.</p>

<p>The routine <i>LLmessage</i> must accept one parameter,
whose value is a token number, zero or -1.<br>
A zero parameter indicates that the current token (the one
in the external variable <i>LLsymb</i>) is deleted.<br>
A -1 parameter indicates that the parser expected end of
file, but didn&rsquo;t get it. The parser will then skip
tokens until end of file is detected.<br>
A parameter that is a token number (a positive parameter)
indicates that this token is to be inserted in front of the
token currently in <i>LLsymb</i>. The user can give the
token the proper attributes. Also, the user must take care,
that the token currently in <i>LLsymb</i> is again returned
by the <b>next</b> call to the lexical analyzer, with the
proper attributes. So, the lexical analyzer must have a
facility to push back one token.</p>

<p>The user may also supply his own error recovery
routines, or handle errors differently. For this purpose,
the name of a routine to be called when an error occurs may
be declared using the keyword <b>%onerror</b>. This routine
takes two parameters. The first one is either the token
number of the token expected, or 0. In the last case, the
error occurred at a choice. In both cases, the routine must
ensure that the next call to the lexical analyser returns
the token that replaces the current one. Of course, that
could well be the current one, in which case <i>LLparse</i>
recovers from the error. The second parameter contains a
list of tokens that are not skipped at the error point. The
list is in the form of a null-terminated array of integers,
whose address is passed.</p>

<p>The user must supply a lexical analyzer to read the
input stream and break it up into tokens, which are passed
to <i>LLparse.</i> It should be an integer valued function,
returning the token number. The name of this function can be
declared using the &quot;<b>%lexical</b>&quot; keyword. This
keyword can be used wherever a declaration is legal and may
appear only once in the grammar specification, f.i.:</p>
<pre>%lexical scanner ;
</pre>

<p>declares &quot;scanner&quot; as the name of the lexical
analyzer. The default name for the lexical analyzer is
&quot;yylex&quot;. The reason for this funny name is that a
useful tool for constructing lexical analyzers is the
<i>Lex</i> program, <small><small>5</small></small> which
generates a routine of that name.</p>

<p>The token numbers are chosen by <i>LLgen</i>. The token
number for a literal is the numerical value of the character
in the local character set. If the tokens have a name, the
&quot;# define&quot; mechanism of C is used to give them a
value and to allow the lexical analyzer to return their
token numbers symbolically. These &quot;# define&quot;s are
collected in the file <i>Lpars.h</i> which can be &quot;#
include&quot;d in any file that needs the token-names. The
maximum token number chosen is defined in the macro
<i>LL_MAXTOKNO</i>.</p>

<p>The lexical analyzer must signal the end of input to
<i>LLparse</i> by returning a number less than or equal to
zero.</p>
<a name="8. Programs with more than one parser"></a>
<h2>8. Programs with more than one parser</h2>

<p><i>LLgen</i> offers a simple facility for having more
than one parser in a program: in this case, the user can
change the names of global procedures, variables, etc, by
giving a different prefix, like this:</p>
<pre>%prefix XX ;
</pre>

<p>The effect of this is that all global names start with
XX instead of LL, for the parser that has this prefix. This
holds for the variables <i>LLsymb</i>, which now is called
<i>XXsymb</i>, for the routine <i>LLmessage</i>, which must
now be called <i>XXmessage</i>, and for the macro
<i>LL_MAXTOKNO</i>, which is now called <i>XX_MAXTOKNO</i>.
<i>LL.output</i> is now <i>XX.output</i>, and <i>Lpars.c</i>
and <i>Lpars.h</i> are now called <i>XXpars.c</i> and
<i>XXpars.h</i>.</p>
<a name="References"></a>
<h2>References</h2>
<a name="References"></a>
<h2>References</h2>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>S. I. Feldman, &ldquo;Make - A Program for Maintaining
Computer Programs,&rdquo; <i>Software - Practice and
Experience,</i> 10, 8, pp. 255-265 (August 1979).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>2.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>M. Griffiths, &ldquo;LL(1) Grammars and Analysers&rdquo;
in <i>Compiler Construction, An Advanced Course,</i> ed. F.
L. Bauer and J. Eickel, Springer-Verlag, New York, N.Y.
(1974).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>3.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>S. C. Johnson, &ldquo;Yacc: Yet Another Compiler
Compiler,&rdquo; Comp. Sci. Tech. Rep. No. 32, Bell
Laboratories, Murray Hill, New Jersey (1975).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>4.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>B. W. Kernighan and D. M. Ritchie, <i>The C Programming
Language,</i> Prentice-Hall, Inc., Englewood Cliffs, New
Jersey (1978).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>5.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>M. E. Lesk, &ldquo;Lex - A Lexical Analyser
Generator,&rdquo; Comp. Sci. Tech. Rep. No. 39, Bell
Laboratories, Murray Hill, New Jersey (October 1975).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>6.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>D. R. Milton, L. W. Kirchhoff, and B. R. Rowland,
&ldquo;An ALL(1) Compiler Generator,&rdquo; <i>SIGPLAN
Notices,</i> 14, 8, pp. 152-157 (August 1979).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>7.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>J. Rohrich, &ldquo;Methods for the Automatic
Construction of Error Correcting Parsers,&rdquo; <i>Acta
Informatica,</i> 13, pp. 115-139 (1980).</p>
</td>
</table>
<a name="Appendix A : LLgen Input Syntax"></a>
<h2>Appendix A : LLgen Input Syntax</h2>

<p>This appendix has a description of the <i>LLgen</i>
input syntax, as a <i>LLgen</i> specification. As a matter
of fact, the current version of <i>LLgen</i> is written with
<i>LLgen</i>.</p>
<pre>/*
 * First the declarations of the terminals
 * The order is not important
 */

%token  IDENTIFIER;            /* terminal or nonterminal name */
%token  NUMBER;
%token  LITERAL;

/*
 * Reserved words
 */

%token  TOKEN;         /* %token */
%token  START;         /* %start */
%token  PERSISTENT;    /* %persistent */
%token  IF;            /* %if */
%token  WHILE;         /* %while */
%token  AVOID;         /* %avoid */
%token  PREFER;        /* %prefer */
%token  DEFAULT;       /* %default */
%token  LEXICAL;       /* %lexical */
%token  PREFIX;        /* %prefix */
%token  ONERROR;       /* %onerror */
%token  FIRST;         /* %first */

/*
 * Declare LLparse to be a C-routine that recognizes &quot;specification&quot;
 */

%start  LLparse, specification;

specification
        : declaration*
        ;

declaration
        : START
                IDENTIFIER &rsquo;,&rsquo; IDENTIFIER
          &rsquo;;&rsquo;
        | &rsquo;{&rsquo;
                /* Read C-declaration here */
          &rsquo;}&rsquo;
        | TOKEN
                IDENTIFIER
                [ &rsquo;,&rsquo; IDENTIFIER ]*
          &rsquo;;&rsquo;
        | FIRST
                IDENTIFIER &rsquo;,&rsquo; IDENTIFIER
          &rsquo;;&rsquo;
        | LEXICAL
                IDENTIFIER
          &rsquo;;&rsquo;
        | PREFIX
                IDENTIFIER
          &rsquo;;&rsquo;
        | ONERROR
                IDENTIFIER
       &rsquo;;&rsquo;
        | rule
        ;

rule    : IDENTIFIER parameters? ldecl?
                &rsquo;:&rsquo; productions
          &rsquo;;&rsquo;
        ;

ldecl   : &rsquo;{&rsquo;
                /* Read C-declaration here */
          &rsquo;}&rsquo;
        ;

productions
        : simpleproduction
          [ &rsquo;|&rsquo; simpleproduction ]*
        ;

simpleproduction
        : DEFAULT?
       [ IF &rsquo;(&rsquo; /* Read C-expression here */ &rsquo;)&rsquo;
          | PREFER
          | AVOID
          ]?
          [ element repeats ]*
        ;

element : &rsquo;{&rsquo;
                /* Read action here */
          &rsquo;}&rsquo;
        | &rsquo;[&rsquo; [ WHILE &rsquo;(&rsquo; /* Read C-expression here */ &rsquo;)&rsquo; ]?
                PERSISTENT?
                productions
          &rsquo;]&rsquo;
        | LITERAL
        | IDENTIFIER parameters?
        ;

parameters
        : &rsquo;(&rsquo; /* Read C-parameters here */ &rsquo;)&rsquo;
        ;

repeats : /* empty */
        | [ &rsquo;*&rsquo; | &rsquo;+&rsquo; ] NUMBER?
        | NUMBER
        | &rsquo;?&rsquo;
        ;

</pre>
<a name="Appendix B : An example"></a>
<h2>Appendix B : An example</h2>

<p>This example gives the complete <i>LLgen</i>
specification of a simple desk calculator. It has 26
registers, labeled &quot;a&quot; through &quot;z&quot;, and
accepts arithmetic expressions made up of the C operators +,
-, *, /, %, &amp;, and |, with their usual priorities. The
value of the expression is printed. As in C, an integer that
begins with 0 is assumed to be octal; otherwise it is
assumed to be decimal.</p>

<p>Although the example is short and not very complicated,
it demonstrates the use of if and while conditions. In the
example they are in fact used to reduce the number of
nonterminals, and to reduce the overhead due to the
recursion that would be involved in parsing an expression
with an ordinary recursive descent parser. In an ordinary
LL(1) grammar there would be one nonterminal for each
operator priority. The example shows how we can do it all
with one nonterminal, no matter how many priority levels
there are.</p>
<pre>{
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#define MAXPRIO      5
#define prio(op)     (ptab[op])

struct token {
        int     t_tokno;        /* token number */
        int     t_tval;         /* Its attribute */
} stok = { 0,0 }, tok;

int     nerrors = 0;
int     regs[26];               /* Space for the registers */
int     ptab[128];              /* Attribute table */

struct token
nexttok() {  /* Read next token and return it */
        register        c;
        struct token    new;

       while ((c = getchar()) == &rsquo; &rsquo; || c == &rsquo;\t&rsquo;) { /* nothing */ }
        if (isdigit(c)) new.t_tokno = DIGIT;
        else if (islower(c)) new.t_tokno = IDENT;
        else new.t_tokno = c;
        if (c &gt;= 0) new.t_tval = ptab[c];
        return new;
}   }

%token  DIGIT, IDENT;
%start  parse, list;

list    : stat* ;

stat    {       int     ident, val; } :
        %if (stok = nexttok(),
             stok.t_tokno == &rsquo;=&rsquo;)
                    /* The conflict is resolved by looking one further
                     * token ahead. The grammar is LL(2)
                     */
          IDENT
                                {       ident = tok.t_tval; }
          &rsquo;=&rsquo; expr(1,&amp;val) &rsquo;\n&rsquo;
                                {       if (!nerrors) regs[ident] = val; }
        | expr(1,&amp;val) &rsquo;\n&rsquo;
                                {       if (!nerrors) printf(&quot;%d\n&quot;,val); }
        | &rsquo;\n&rsquo;
        ;

expr(int level; int *val;) {       int     expr; } :
          factor(val)
          [ %while (prio(tok.t_tokno) &gt;= level)
                    /* Swallow operators as long as their priority is
                     * larger than or equal to the level of this invocation
                     */
              &rsquo;+&rsquo; expr(prio(&rsquo;+&rsquo;)+1,&amp;expr)
                                {       *val += expr; }
                    /* This states that &rsquo;+&rsquo; groups left to right. If it
                     * should group right to left, the rule should read:
                     * &rsquo;+&rsquo; expr(prio(&rsquo;+&rsquo;),&amp;expr)
                     */
            | &rsquo;-&rsquo; expr(prio(&rsquo;-&rsquo;)+1,&amp;expr)
                                {       *val -= expr; }
            | &rsquo;*&rsquo; expr(prio(&rsquo;*&rsquo;)+1,&amp;expr)
                                {       *val *= expr; }
            | &rsquo;/&rsquo; expr(prio(&rsquo;/&rsquo;)+1,&amp;expr)
                                {       *val /= expr; }
            | &rsquo;%&rsquo; expr(prio(&rsquo;%&rsquo;)+1,&amp;expr)
                                {       *val %= expr; }
            | &rsquo;&amp;&rsquo; expr(prio(&rsquo;&amp;&rsquo;)+1,&amp;expr)
                                {       *val &amp;= expr; }
            | &rsquo;|&rsquo; expr(prio(&rsquo;|&rsquo;)+1,&amp;expr)
                                {       *val |= expr; }
          ]*
                    /* Notice the &quot;*&quot; here. It is important.
                     */
     ;

factor(int *val;):
            &rsquo;(&rsquo; expr(1,val) &rsquo;)&rsquo;
          | &rsquo;-&rsquo; expr(MAXPRIO+1,val)
                                {       *val = -*val; }
          | number(val)
          | IDENT
                                {       *val = regs[tok.t_tval]; }
        ;

number(int *val;) {       int base; }
        : DIGIT
                                {       base = (*val=tok.t_tval)==0?8:10; }
          [ DIGIT
                                {       *val = base * *val + tok.t_tval; }
          ]*        ;

%lexical scanner ;
{
scanner() {
        if (stok.t_tokno) { /* a token has been inserted or read ahead */
                tok = stok;
                stok.t_tokno = 0;
                return tok.t_tokno;
        }
        if (nerrors &amp;&amp; tok.t_tokno == &rsquo;\n&rsquo;) {
                printf(&quot;ERROR\n&quot;);
                nerrors = 0;
        }
        tok = nexttok();
        return tok.t_tokno;
}

LLmessage(insertedtok) {
        nerrors++;
        if (insertedtok) { /* token inserted, save old token */
                stok = tok;
                tok.t_tval = 0;
                if (insertedtok &lt; 128) tok.t_tval = ptab[insertedtok];
        }
}

main() {
        register *p;

       for (p = ptab; p &lt; &amp;ptab[128]; p++) *p = 0;
        /* for letters, their attribute is their index in the regs array */
        for (p = &amp;ptab[&rsquo;a&rsquo;]; p &lt;= &amp;ptab[&rsquo;z&rsquo;]; p++) *p = p - &amp;ptab[&rsquo;a&rsquo;];
        /* for digits, their attribute is their value */
        for (p = &amp;ptab[&rsquo;0&rsquo;]; p &lt;= &amp;ptab[&rsquo;9&rsquo;]; p++) *p = p - &amp;ptab[&rsquo;0&rsquo;];
        /* for operators, their attribute is their priority */
        ptab[&rsquo;*&rsquo;] = 4;
        ptab[&rsquo;/&rsquo;] = 4;
        ptab[&rsquo;%&rsquo;] = 4;
        ptab[&rsquo;+&rsquo;] = 3;
        ptab[&rsquo;-&rsquo;] = 3;
        ptab[&rsquo;&amp;&rsquo;] = 2;
        ptab[&rsquo;|&rsquo;] = 1;
        parse();
     exit(nerrors);
}   }
</pre>
<a name="Appendix C. How to use LLgen ."></a>
<h2>Appendix C. How to use LLgen .</h2>

<p>This appendix demonstrates how <i>LLgen</i> can be used
in combination with the <i>make</i> program, to make
effective use of the <i>LLgen</i>-feature that it only
changes output files when neccessary. <i>Make</i> uses a
&quot;makefile&quot;, which is a file containing
dependencies and associated commands. A dependency usually
indicates that some files depend on other files. When a file
depends on another file and is older than that other file,
the commands associated with the dependency are
executed.</p>

<p>So, <i>make</i> seems just the program that we always
wanted. However, it is not very good in handling programs
that generate more than one file. As usual, there is a way
around this problem. A sample makefile follows:</p>
<pre># The grammar exists of the files decl.g, stat.g and expr.g.
# The &quot;.o&quot;-files are the result of a C-compilation.

GFILES = decl.g stat.g expr.g
OFILES = decl.o stat.o expr.o Lpars.o
LLOPT =

# As make does&rsquo;nt handle programs that generate more than one
# file well, we just don&rsquo;t tell make about it.
# We just create a dummy file, and touch it whenever LLgen is
# executed. This way, the dummy in fact depends on the grammar
# files.
# Then, we execute make again, to do the C-compilations and
# such.

all: dummy
        make parser

dummy:  $(GFILES)
        LLgen $(LLOPT) $(GFILES)
        touch dummy

parser: $(OFILES)
        $(CC) -o parser $(LDFLAGS) $(OFILES)

# Some dependencies without actions :
# make already knows what to do about them

Lpars.o:        Lpars.h
stat.o:         Lpars.h
decl.o:         Lpars.h
expr.o:         Lpars.h

</pre>
<hr>
</body>
</html>
